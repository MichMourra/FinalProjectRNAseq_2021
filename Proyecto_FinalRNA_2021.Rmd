---
title: "ProyectoFinalRNA"
output: html_document
---

# Captura de Datos

## Busqueda de proyectos

```{r,message=FALSE}
library("recount3")
```

Encontramos todos los proyectos realizados en humanos.

```{r,message=FALSE}
# Capturamos todos los proyectos en humanos
human_projects <- available_projects()
```

Vemos cuales son los proyectos que podemos elegir.

```{r}
# Exploramos los proyectos humanos
human_projects
```

Para este caso elegimos el proyecto SRP071965 acerca de la identificación de biomarcadores sanguíneos que predicen prospectivamente la progresión de la infección por Mycobacterium tuberculosis, esto con el proposito de poder detectar lo mas pronto posible la enfermedad.

Estos estudios fueron realizados en Sudafrica y Gambia.

Para mas información visita NCBI: 
https://www.ncbi.nlm.nih.gov/sra/SRX2469204[accn]

```{r,message=FALSE}
# Capturamos nuestro proyecto de interes
rse_gene_SRP071965  <- create_rse(
    subset(
        human_projects,
        project == "SRP071965" & project_type == "data_sources"
    )
)
```

```{r}
# Exploramos la información de nuestro proyecto
rse_gene_SRP071965 
```


Podemos ver que tenemos 63856 genes en 355 muestras 

Con compute_read_counts obtendremos el numero de lecturas para cada una de las muestras en lugar de los datos a nivel de nucleotidos.

```{r}
# Cambiar el numero de lecturas de nucleotidos a muestras
assay(rse_gene_SRP071965 , "counts") <- compute_read_counts(rse_gene_SRP071965)
```

## Exploramos nuestros datos

Si queremos revisar la información contenida en las columnas

```{r,eval=FALSE}
head(colData(rse_gene_SRP071965))
```

Si queremos revisar la información contenida en rowData

```{r,eval=FALSE}
rowData(rse_gene_SRP071965)
```

La variable de sra.sample_attributes, nos permite ver si la información viene diferente entre las muestras.

```{r}
rse_gene_SRP071965$sra.sample_attributes[1:4]
```


```{r}
library("edgeR")
```

Podemos observar que las lineas poseen la misma cantidad de campos, por lo que podemos proceder a observar la información contenida en las columnas

```{r}
rse_gene_SRP071965 <- expand_sra_attributes(rse_gene_SRP071965)

colData(rse_gene_SRP071965)[
    ,
    grepl("^sra_attribute", colnames(colData(rse_gene_SRP071965)))
]
```

Observamos los valores unicos de cada uno de los campos que tiene el experimento

```{r}
# Accedemos a los valores unicos de los datos
print("Group")
unique(rse_gene_SRP071965$sra_attribute.group) 
print("Gender")
unique(rse_gene_SRP071965$sra_attribute.gender)
print("Ethnicity")
unique(rse_gene_SRP071965$sra_attribute.ethnicity)
```

```{r}
## Podemos pasar los atributos de edad y bin a variable tipo numerica
rse_gene_SRP071965$sra_attribute.age <- as.numeric(rse_gene_SRP071965$sra_attribute.age)

rse_gene_SRP071965$sra_attribute.bin <- as.numeric(rse_gene_SRP071965$sra_attribute.bin)

## Podemos pasar el grupo etnico, el grupo y el genero a factor
rse_gene_SRP071965$sra_attribute.group <- factor(rse_gene_SRP071965$sra_attribute.group)

rse_gene_SRP071965$sra_attribute.ethnicity <- factor(rse_gene_SRP071965$sra_attribute.ethnicity)

rse_gene_SRP071965$sra_attribute.gender <- factor(rse_gene_SRP071965$sra_attribute.gender)
```

Observamos la información de cada uno de los campos para proceder con la limpieza de los datos

```{r}
## Resumen de las variables de interés y mostramos la información relevante de cada campo
summary(as.data.frame(colData(rse_gene_SRP071965)[
    ,
    grepl("^sra_attribute.[group|age|bin|ethnicity|gender]", colnames(colData(rse_gene_SRP071965)))
]))
```

Se inspecciona el estado de los pacientes

```{r}
#generamos nuestra columna dependiendo de si el paciente es control o caso
rse_gene_SRP071965$Group <- factor(ifelse(rse_gene_SRP071965$sra_attribute.group == "control (non-progressor)", "Control", "Case"))

table(rse_gene_SRP071965$Group)
```

Observamos el conteo de expresión

```{r}
# Desplegamos la expresión
rse_gene_SRP071965$assigned_gene_prop <- rse_gene_SRP071965$recount_qc.gene_fc_count_all.assigned / rse_gene_SRP071965$recount_qc.gene_fc_count_all.total
summary(rse_gene_SRP071965$assigned_gene_prop)
```

Se da un vistazo general de la expresión de los genes en las muestras

```{r}
# Realizamos un plot de la expresión
with(colData(rse_gene_SRP071965), plot(assigned_gene_prop, sra_attribute.bin))
abline(v=0.64,col = "red")
```

```{r}
with(colData(rse_gene_SRP071965), tapply(assigned_gene_prop, Group, summary))
```

# Limpieza de muestras

```{r}
## Guardemos nuestro objeto entero por si luego cambiamos de opinión
rse_gene_SRP071965_unfiltered <- rse_gene_SRP071965

## Eliminemos a muestras malas
hist(rse_gene_SRP071965$assigned_gene_prop)
abline(v=0.64,col="red")
```

Observamos cuantos cumplen con el punto de corte establecido tras la observación

```{r}
table(rse_gene_SRP071965$assigned_gene_prop < 0.64)
```

Calculamos los nuevos valores una vez hecho el filtrado de las muestras poco informativas

```{r}
rse_gene_SRP071965 <- rse_gene_SRP071965[, rse_gene_SRP071965$assigned_gene_prop > 0.64]

## Calculemos los niveles medios de expresión de los genes en nuestras
## muestras.
## Ojo: en un análisis real probablemente haríamos esto con los RPKMs o CPMs
## en vez de las cuentas.
gene_means <- rowMeans(assay(rse_gene_SRP071965, "counts"))
summary(gene_means)
```

# Limpieza de genes

```{r}
## Eliminamos genes
rse_gene_SRP071965 <- rse_gene_SRP071965[gene_means > 0.01, ]

## Dimensiones finales
dim(rse_gene_SRP071965)
```

```{r}
## Dimensiones finales
dim(rse_gene_SRP071965_unfiltered)
```

Vemos que debido a la calidad se tuvo que limpiar la mitad de las muestras

```{r}
round(nrow(rse_gene_SRP071965) / nrow(rse_gene_SRP071965_unfiltered) * 100, 2)
```

# Normalización de los datos

```{r,message=FALSE}
library("edgeR") # BiocManager::install("edgeR", update = FALSE)
dge <- DGEList(
    counts = assay(rse_gene_SRP071965, "counts"),
    genes = rowData(rse_gene_SRP071965)
)
dge <- calcNormFactors(dge)
```


```{r}
library("ggplot2")
ggplot(as.data.frame(colData(rse_gene_SRP071965)), aes(y = assigned_gene_prop, x = Group)) +
    geom_boxplot() +
    theme_bw(base_size = 20) +
    ylab("Assigned Gene Prop") +
    xlab("Life Level")
```

```{r}
mod <- model.matrix(~ Group + sra_attribute.age + sra_attribute.gender + sra_attribute.ethnicity + sra_attribute.bin + assigned_gene_prop,
    data = colData(rse_gene_SRP071965)
)
colnames(mod)
```

```{r}
library("limma")
vGene <- voom(dge, mod, plot = TRUE)
```

```{r}
eb_results <- eBayes(lmFit(vGene))

de_results <- topTable(
    eb_results,
    coef = 2,
    number = nrow(rse_gene_SRP071965),
    sort.by = "none"
)
dim(de_results)
```


```{r}
head(de_results)
```

```{r}
## Genes diferencialmente expresados entre embrion y humano con FDR < 5%
table(de_results$adj.P.Val < 0.05)
```


```{r}
## Visualicemos los resultados estadísticos
plotMA(eb_results, coef = 2)
```

```{r}
volcanoplot(eb_results, coef = 2, highlight = 3, names = de_results$gene_name)
```

```{r}
de_results[de_results$gene_name %in% c("GBP6", "LIPM", "RP5-998N21.4"), ]
```

```{r}
## Extraer valores de los genes de interés
exprs_heatmap <- vGene$E[rank(de_results$adj.P.Val) <= 50, ]

## Creemos una tabla con información de las muestras
## y con nombres de columnas más amigables
df <- as.data.frame(colData(rse_gene_SRP071965)[, c("Group", "sra_attribute.age", "sra_attribute.gender","sra_attribute.ethnicity")])
colnames(df) <- c("Group", "Age", "Gender", "Ethnicity")

## Hagamos un heatmap
library("pheatmap")
pheatmap(
    exprs_heatmap,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    show_rownames = FALSE,
    show_colnames = FALSE,
    annotation_col = df
)
```


```{r,message=FALSE}
## Para colores
library("RColorBrewer")

## Conviertiendo los grupos de edad a colores
col.group <- df$Group
levels(col.group) <- brewer.pal(nlevels(col.group), "Set1")
```

```{r}
col.group <- as.character(col.group)

## MDS por grupos de edad
plotMDS(vGene$E, labels = df$Group , col = col.group)
```

```{r}
## Para colores
library("RColorBrewer")

## Conviertiendo los grupos de edad a colores
col.group <- df$Group
levels(col.group) <- brewer.pal(nlevels(col.group), "Set1")
```

```{r}
## Conviertiendo los valores de Sex a colores
col.sex <- df$Gender
levels(col.sex) <- brewer.pal(nlevels(col.sex), "Dark2")
```

```{r}
col.sex <- as.character(col.sex)

## MDS por sexo
plotMDS(vGene$E, labels = df$Gender, col = col.sex)
```









